### 1.排序算法的时间复杂度

_时间复杂度_:反应了算法的执行时间,随问题的规模增长而增长的趋势,他的执行时间主要是有算法的执行次数定义的,问题的规模不一定能够被清晰地定义,但他往往和数据的大小相关  
  
O(1) :常数时间复杂度:算法的时间不随规模的变化而变化(给定位置链表的插入删除 数组的下表操作 哈希的增删该查 线性表的两端进行操作 )  
O(log N) : 对数时间复杂度:问题的规模成倍增长的情况下,执行次数线性增长[有序数组的二分法查找 有序二叉树的各种操作]  
在工程实践当中,同时能够兼顾平衡性与操作效率的二叉树搜索树结构时红黑树  
O(N) :线性事件复杂度[数组的遍历  链表的查找  链表的下表索引]  
O(N*log N) :如果一个算法的时间复杂度能够被多项式界定,又称NP 问题  
  
在工程实践中,往往采用多种数据结构维护同一批对象的方法使得程序兼有各种数据结构的优点[Linux内核:用链表结构维护进程等待的队列,用红黑树结构维护进程的就绪集合  
针对数据库的某个字段建立索引,在操作数据时同时对这几种数据结构进行操作]  

_空间复杂度_:是指算法在计算机内执行时所需要的内存空间,它是温柔提规模n的函数  
O(1) :当一个算法的空间复杂度为一个常量,不随处理数据量n的大小而改变[ 斐波那契数列 归并 堆]  
O(log N) :[快速排序]  
O(N) :[基数]  

### 2.数据结构

_链表_: 单向链表 有头有尾  ,双向链表
  工程实践当中该如何去构建链表  在链表以及其他的基于对象之间的引用而形成的对象结构如果频繁的向系统  
  内存申请或释放内存会造成性能的低下和内存碎片,所以多用对象池进行管理  
  
  对象池: 一次性的批量分配对象(特点:1.同样规模 2.一次分配 3.维护空间) 避免了反复申请的开销,维护成一个链表结构,每次分配对象时从链表头部去除,  
  释放对象后将对象归还给链表头部,之所以我们自己的对象池比系统分配对象还要高效的原因在于系统的内存管理器考虑到各种情形进行分类检查,而我们创建的  
  对象池只是针对莫衷特定大小的对象进行维护,所以可以很高效的进行对象分类  
  建立两个链表,一个维护存储可用的空间,一个维护调用的空间,和一个值记录标记下标  

_栈_:一般操作 push pop empty 等  可以用 数组,链表去构建
  用数组加一个标记就可以搞笑的实现栈,常见用途直接用于算法实际(如果问题需要 先记住什么  用到的时候需要往回找 南无可能涉及到一个或多个栈),可以把递归  
  的算法改成非递归的模式,可以用于程序运行当中的子过程调用的信息
  
_队列_: 队列应用场景比较直接,可以用一个数组和两个标记来构建一个队列,常用在进程线程的通信,如线程编程中生产者消费者模式,广度优先搜索(树的按层遍历),  
图的路径搜索(往往用的是优先队列)

_树_:(特点:全联通 无环图) 用来表示信息层形式的数据结构.  

作用 :
1.有些数据天生就是树结构,htmlDOM ,json,xml,文件系统  
2.有意识的把数据组成树形结构,尤其是二叉树搜索树结构,它是一种常见的索引  
3.在一系列的决策或操作步骤形成的解空间里进行搜索  
  
树的存储: 树的每个节点要维护子节点和父节点的引用(在实际情况中并不一定要全都维护)  
树的遍历:深度优先,广度优先  


_二叉树_:每个节点有左子节点和右子节点,二叉树应用(搜素二叉树建立索引 这样的二叉树需要保持其平衡性,  

在在工程实践中兼顾平衡性和效率的代表是红黑树,用在数据库索引 操作系统的进程调度和内存管理)  

遍历方式: 按层遍历(广度优先---> 往往需要使用队列来辅助算法实现)  前中后序遍历(深度优先 --->往往需要使用栈来辅助算法实现[递归 ]  )  
前序: 根前序  根 左右,中序: 左 根在中 右,后序: 左 右 根  
递归的优劣:用递归的形式设计算法往往会非常简单,但是程序运行当中栈的大小往往是受限的,32位系统默认进程,使用的栈大小为 8M ,递归会产生额外的调用的开销.所以在实际当中往往会把递归形式的算法重写为栈的形式


_图_:图的搜索:Dijkstra(迪杰斯拉算法) 基于广度优先搜索,在搜索的'前延'(open集合)   
每次挑选路径代价最小的节点,再次进行搜索,根据节点相邻边的搜索结果的权重 更新搜索前言及路径代价 如此周而复始(指的是周围那圈) , 直到目标节点进出到close集合  
A*:当图的节点包含位置信息时,可以通过估算open集合的节点到目标节点的距离来加速搜索过程.在open集合中选取,g(n)+h(n)最小的节点进行下一步搜索,g(n)出发点到该节点路径  h(n)是目标估计   
优先队列(二叉堆): 在整个算法运行中  open集合的数据结构是优先队列  

###3.操作系统
node 异步机制  
socket(△) --->bind(△) --->listen(△) --->epoll(△ □ □ □ ... ) <= □+ =>accept | <==>AIO callblock() 
 
监听一个文件描述符(△)集合,当文件描述符的状态改变时,可读可写有新的连接进入,方法返回,并给出该文件描述符状态的变化,   
如果是监听套接字,则accept新增一个文件描述符,如果时IO套接字,则注册相应的回调方法.无论何时主线程只会阻塞在epoll,IO请求有操作系统内核完成后调用注册的回调.  
对于回调函数的要求:1.不可阻塞2.避免进行大量计算3.尽快返回,如果回调函数不能全部异步去执行,则另开进程或另写程序与其通信实现异步操作.
epoll/poll/select 是操作系统提供的IO多路监听机制
